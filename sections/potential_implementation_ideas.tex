\section{Implementation Considerations}

Since the core requirements of the project are architecture-independent to some degree, a simple solution which is not fully decentralised is a good option to begin with.

At current, a potential implementation utilises the following technologies:

\begin{outline}
  \1 AWS S3 (file/blob storage)
  \1 AWS EB (scalable application endpoints)
  \1 AWS RDS (SQL database)
  \1 Ethereum (Blockchain-based decentralised applications)
  \1 Electron (desktop application wrapper)
\end{outline}

Whilst centralised, Amazon Web Services (AWS) provides a solid and stable platform for the deployment of the application. Well-tested and production-ready software such as PostgreSQL, Amazon S3, and Amazon Elastic Beanstalk (running docker) not only provide a durable and dependable deployment solution, but also allow the development and production environments to be mirrored such that development need not take place online.

% PARTY A
% Private (unencrypted?) data
% Private key / Public key pair

% PARTY B
% Private (unencrypted?) data
% Private key / Public key pair

% PROXY
% Public keys for all users / institutions (verifies the identity of a party and allows re-encryption)
% Re-encryption keys for each API access (requires the 3rd party to read data)
% Encrypted data (using owner's private key - not readable by anyone else)

% No private keys nor unencrypted data is shared in the network
% Upon granting access, the user's device generates the re-encryption key locally (potentially multiple keys whereby the data is readable by anyone but the data is verified to be encrypted by a particular device??)
% This would require the use of proxy-reencryption such that any data uploaded by any device could be re-encrypted to be decrypted by any of the user's devices

% User passes private and encrypted data to proxy
% User sends the re-encryption key and access
% Access logs are encrypted with the user's public key as blobs on blockchain - only readable by the user themselves
% Who owns data - where do we store data that is written by party a but belongs to party b?

% What about if you used IPFS across public hardware - individuals etc. to create the world's biggest network of file storage stations, the mining being the storage of files, paid for by people using the network to store encrypted data. Filecoin?

The application would be distributed such that it could run on desktop operating systems (Mac and Linux (Debian) initially\footnote{Deployment of other packages may incur more overhead unnecessary at this point}). This means that the backend services of the project would be distinct from any front-end, whilst a public API offers the opportunity for third parties to contribute data and encourage user adoption.

The project architecture could be modelled, to some extent, by the following:

\input{tikz/architecture_potential_centralised_compute}
